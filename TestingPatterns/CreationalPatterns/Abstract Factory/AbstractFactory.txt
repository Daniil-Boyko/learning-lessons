ABSTRACT FACTORY
Этот паттерн решает проблему создания целых семейств связанных продуктов, без указания конкретных классов продуктов
Создаем интерфейс абстрактной фабрики, в которых описаны методы создания продуктов в соответствующих интерфейсах абстрактных продуктов
    interface AbstractFactory
    {
        public function createProductA(): AbstractProductA;
        public function createProductB(): AbstractProductB;
    }
Создаем интерфейсы абстрактных продуктов, которые описывают методы создания продуктов
(здесь продукт B будет как бы "дополнять" или "коллаборировать" с продуктом А
    interface AbstractProductA
    {
        public function usefulFunctionA(): string;
    }

    interface AbstractProductB
    {
        public function usefulFunctionB(): string;
        public function anotherUsefulFunctionB(AbstractProductA $collaborator): string;
    }
Создаем класс конкретной фабрики 1, который имплементирует методы абстрактной фабрики
    class ConcreteFactory1 implements AbstractFactory
    {
        /**
         * @return AbstractProductA
         */
        #[Pure] public function createProductA(): AbstractProductA
        {
            // TODO: Implement createProductA() method.
            return new ConcreteProductA;
        }

        /**
         * @return AbstractProductB
         */
        #[Pure] public function createProductB(): AbstractProductB
        {
            // TODO: Implement createProductB() method.
            return new ConcreteProductB;
        }
    }
Создаем класс конкретной фабрики 2, который имплементирует методы абстрактной фабрики
    class ConcreteFactory2 implements AbstractFactory
    {
        /**
         * @return AbstractProductA
         */
        #[Pure] public function createProductA(): AbstractProductA
        {
            // TODO: Implement createProductA() method.
            return new ConcreteProductA2;
        }

        /**
         * @return AbstractProductB
         */
        #[Pure] public function createProductB(): AbstractProductB
        {
            // TODO: Implement createProductB() method.
            return new ConcreteProductB2;
        }
    }
Создаем класс конкретного продукта А1, который имплементирует методы интерфейса абстрактного продукта А
    class ConcreteProductA implements AbstractProductA
    {
        public function usefulFunctionA(): string
        {
            // TODO: Implement usefulFunctionA() method.
            return "The result of the product A1.";
        }
    }
Также для А2:
    class ConcreteProductA2 implements AbstractProductA
    {
        public function usefulFunctionA(): string
        {
            // TODO: Implement usefulFunctionA() method.
            return "The result of the product A2.";
        }
    }
Создаем класс конкретного продукта B1, который имплементирует методы интерфейса абстрактного продукта B
    class ConcreteProductB implements AbstractProductB
    {
        public function usefulFunctionB(): string
        {
            // TODO: Implement usefulFunctionB() method.
            return "The result of the product B1.";
        }

        public function anotherUsefulFunctionB(AbstractProductA $collaborator): string
        {
            $result = $collaborator->usefulFunctionA();

            // TODO: Implement anotherUsefulFunctionB() method.
            return "The result of the B1 collaborating with the ($result)";
        }
    }
Также для B2:
    class ConcreteProductB2 implements AbstractProductB
    {
        public function usefulFunctionB(): string
        {
            // TODO: Implement usefulFunctionB() method.
            return "The result of the product B2.";
        }

        public function anotherUsefulFunctionB(AbstractProductA $collaborator): string
        {
            // TODO: Implement anotherUsefulFunctionB() method.
            $result = $collaborator->usefulFunctionA();

            return "The result of the B2 collaborating with ($result)";
        }
    }
Делаем часть клиентского кода, в которой вызываются методы создания продуктов А и B
    function clientCode(AbstractFactory $factory)
    {
        $productA = $factory->createProductA();
        $productB = $factory->createProductB();

        echo $productB->usefulFunctionB() . PHP_EOL;
        echo $productB->anotherUsefulFunctionB($productA) . PHP_EOL;
    }
Вызываем такую фабрику, продукты которых хотим создать:
    echo "Client: Testing client code with the first factory type " . PHP_EOL;
    clientCode(new ConcreteFactory1());

    echo PHP_EOL;

    echo "Client: Testing the same client code with the second factory type" . PHP_EOL;
    clientCode(new ConcreteFactory2());
